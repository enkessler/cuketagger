#!/usr/bin/env ruby
# encoding: utf-8

require "cucumber"
require "cucumber/feature_file"
require "cucumber/formatter/pretty"
require "set"

class Tagger
  USAGE = "#{File.basename $0} [-f|--force] [add|remove]:TAG [FILE[:LINE]]+"

  def self.execute(args)
    new.execute(args)
  end

  def execute(args)
    abort(USAGE) if args.empty? || args.first =~ /^(-h|--help)$/
    opts = {:dry_run => true, :source => true}

    args.each do |arg|
      case arg
      when /^(.+?\.feature)(:\d+)?$/
        add_feature($1, $2)
      when /^(add|remove):(.+?)$/
        alterations << [$1.to_sym, $2]
      when /^(-f|--force)$/
        opts[:autoformat] = "."
        opts[:source] = false
        Term::ANSIColor.coloring = false
      else
        abort(USAGE)
      end
    end

    features.accept TagVisitor.new(self, step_mother, $stdout, opts)
  end

  def process(feature, element, tag_names)
    return unless should_alter?(feature, element)

    alterations.each do |op, tag_name|
      case op
      when :add
        tag_names.push tag_name
      when :remove
        tag_names.delete tag_name
      end
    end
  end

  def should_alter?(feature, element)
    line    = element ? element.line : 0
    success = features_to_change.include? [feature.file, line]

    if $DEBUG
      p :feature_class => feature.class, :element_class => element.class, :line => line, :success => success
      p :features_to_change => features_to_change
    end

    success
  end

  private

  def add_feature(path, line)
    ff = Cucumber::FeatureFile.new(path).parse(step_mother, {})
    features_to_change << [path, line.to_s[1,line.length].to_i]
    features.add_feature ff
  end

  def step_mother
    @step_mother ||= Cucumber::StepMother.new
  end

  def features
    @features ||= Cucumber::Ast::Features.new
  end

  def alterations
    @alterations ||= Set.new
  end

  def features_to_change
    @features_to_change ||= Set.new
  end

end

class TagVisitor < Cucumber::Formatter::Pretty

  def initialize(tagger, step_mother, io, options)
    @tagger = tagger
    super(step_mother, io, options)
  end


  def visit_feature(feature)
    @current_feature = feature
    super
  end

  def visit_feature_element(element)
    @current_element = element
    super
    @current_element = nil
  end

  def visit_tags(tags)
    @tagger.process(@current_feature, @current_element, tags.instance_variable_get("@tag_names"))
    super
  end

  private

  def record_tag_occurrences(*args)
    # override to avoid error if options[:include_tags] is nil
  end

end

Tagger.execute(ARGV)
